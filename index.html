<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HastaLuego</title>
  <style>
    /* Style général pour le jeu */
    html, body {
      margin: 0;
      padding: 0;
      background: #000; /* Fond noir pendant le chargement */
      overflow: hidden; /* Éviter les scrollbars */
      height: 100%;
      width: 100%;
    }
    #game {
      position: relative;
      width: 100%;
      height: 100vh;
      background: url("data:image/png;base64,<?=?>") repeat-y center top;
      /* Le fond est une image pixel art répétée verticalement (mer) */
    }
    /* On utilise image-rendering pour un effet pixelisé net */
    #game, .sprite {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .sprite {
      position: absolute;
    }
    /* Tailles des sprites (chaque sprite a une classe dédiée) */
    .boat   { width: 48px; height: 48px; }
    .rock   { width: 32px; height: 32px; }
    .redBuoy    { width: 20px; height: 20px; }
    .greenBuoy  { width: 20px; height: 20px; }
    .flag   { width: 48px; height: 48px; }
    /* Styles pour les écrans de démarrage et de fin */
    .overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    #start-screen {
      /* Visible au début, masqué au démarrage du jeu */
    }
    #final-screen {
      display: none;
      /* Affiché à la fin avec le message de victoire */
    }
    .highlight-date {
      color: yellow;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="game">
    <!-- Bateau du joueur (sprite voilier) -->
    <img id="boat" class="sprite boat" src="data:image/png;base64,<?=?>" alt="Voilier">
    <!-- Écran de démarrage avec instructions -->
    <div id="start-screen" class="overlay">
      <div>
        <p>À l’aide des touches directionnelles, emmène ton bateau à bon port&nbsp;!</p>
        <p>ESPACE pour commencer</p>
      </div>
    </div>
    <!-- Écran de fin avec message final -->
    <div id="final-screen" class="overlay">
      <div id="final-text"></div>
    </div>
    <!-- (Les obstacles et le drapeau de fin seront générés dynamiquement) -->
  </div>
  <!-- Audio de fond -->
  <audio id="bgm" src="assets/hasta-luego.mp3" preload="auto" loop></audio>
  <script>
    // Éléments principaux
    const gameContainer = document.getElementById('game');
    const boat = document.getElementById('boat');
    const startScreen = document.getElementById('start-screen');
    const finalScreen = document.getElementById('final-screen');
    const finalText = document.getElementById('final-text');
    const audio = document.getElementById('bgm');
    // Dimensions du conteneur (mises à jour à l'initialisation)
    let containerWidth, containerHeight;
    // Tailles des sprites utilisées (en pixels à l'écran)
    const spriteSizes = {
      boat:  { w: 48, h: 48 },
      rock:  { w: 32, h: 32 },
      red:   { w: 20, h: 20 },
      green: { w: 20, h: 20 },
      flag:  { w: 48, h: 48 }
    };
    // Position et vitesse du bateau
    let boatX = 0, boatY = 0;
    const boatSpeedX = 5; // déplacement horizontal du voilier (pixels par tick)
    // Vitesse de défilement du fond (et des obstacles)
    let baseSpeed = 2;      // base (pixels par frame)
    let speedFactor = 1;    // facteur de vitesse (1 par défaut, modifié par flèches haut/bas)
    // Obstacles actifs dans le jeu
    let obstacles = [];
    let obstaclesPassed = 0;  // compteur d'obstacles franchis avec succès
    // État du jeu : 'start' (avant départ), 'playing' (jeu en cours), 
    // 'finalApproach' (phase finale, voilier vers le drapeau), 'ended' (jeu terminé)
    let gameState = 'start';
    // Timer pour démarrage automatique
    let autoStartTimer = null;
    // Identifiant de l'intervalle de génération d'obstacles
    let spawnIntervalId = null;
    // Position verticale de l'arrière-plan (pour l'animation du fond)
    let backgroundOffset = 0;
    // Sprites encodés en base64 (pour création dynamique des obstacles et du drapeau)
    const SPRITES = {
      rock: "data:image/png;base64,<?=?>",
      red:  "data:image/png;base64,<?=?>",
      green:"data:image/png;base64,<?=?>",
      flag: "data:image/png;base64,<?=?>"
    };
    // Fonction utilitaire de création d'un obstacle
    function createObstacle(type, x, y) {
      const img = new Image();
      // Attribuer la source base64 selon le type
      img.src = SPRITES[type];
      // Définir la classe appropriée pour taille + style
      if (type === 'red') {
        img.className = 'sprite redBuoy';
      } else if (type === 'green') {
        img.className = 'sprite greenBuoy';
      } else {
        img.className = 'sprite ' + type;
      }
      img.style.left = x + 'px';
      img.style.top = y + 'px';
      gameContainer.appendChild(img);
      // Retourner l'objet obstacle avec ses propriétés utiles
      return { elem: img, type: type, x: x, y: y, w: spriteSizes[type].w, h: spriteSizes[type].h };
    }
    // Suppression d'un obstacle (du DOM et du tableau)
    function removeObstacle(index) {
      if (index >= 0 && index < obstacles.length) {
        const obs = obstacles[index];
        gameContainer.removeChild(obs.elem);
        obstacles.splice(index, 1);
      }
    }
    // Réinitialisation complète du jeu (après un échec, pour rejouer)
    function resetGame() {
      // Supprimer tous les obstacles affichés
      for (let i = obstacles.length - 1; i >= 0; i--) {
        gameContainer.removeChild(obstacles[i].elem);
      }
      obstacles = [];
      obstaclesPassed = 0;
      // Remettre le bateau au centre-bas du conteneur
      boatX = (containerWidth - spriteSizes.boat.w) / 2;
      boatY = containerHeight * 0.8;
      boat.style.left = boatX + 'px';
      boat.style.top = boatY + 'px';
      // Réinitialiser la vitesse de défilement
      baseSpeed = 2;
      speedFactor = 1;
      backgroundOffset = 0;
    }
    // Démarrage du jeu
    function startGame() {
      // Masquer l'écran de démarrage s'il est toujours visible
      startScreen.style.display = 'none';
      // Masquer l'écran de fin au cas où on rejouerait après une victoire
      finalScreen.style.display = 'none';
      // Réinitialiser l'état du jeu
      resetGame();
      gameState = 'playing';
      // Lancer la musique de fond (autoplay ou sur interaction utilisateur)
      audio.play().catch(err => {
        console.log("Audio non démarré automatiquement (attendra une interaction).");
      });
      // Commencer à générer des obstacles à intervalle régulier (toutes les 2.5s)
      spawnIntervalId = setInterval(spawnObstacle, 2500);
      // Lancer la boucle de jeu principale si ce n'est pas déjà fait
      if (!gameLoopRunning) {
        gameLoopRunning = true;
        requestAnimationFrame(gameLoop);
      }
    }
    // Séquence de victoire : le joueur a franchi 12 obstacles
    function winGame() {
      // Arrêter la génération de nouveaux obstacles
      clearInterval(spawnIntervalId);
      spawnIntervalId = null;
      // Retirer tous les obstacles restants du DOM
      for (let i = obstacles.length - 1; i >= 0; i--) {
        removeObstacle(i);
      }
      // Créer le drapeau d'arrivée (jaune) et l'ajouter au jeu
      const flagElem = new Image();
      flagElem.src = SPRITES.flag;
      flagElem.className = 'sprite flag';
      // Placer le drapeau en haut de l'écran, centré horizontalement
      const flagX = (containerWidth - spriteSizes.flag.w) / 2;
      const flagY = 50; // position verticale (50px depuis le haut)
      flagElem.style.left = flagX + 'px';
      flagElem.style.top = flagY + 'px';
      gameContainer.appendChild(flagElem);
      // Passer à l'état finalApproach (le bateau se déplace vers le drapeau)
      gameState = 'finalApproach';
    }
    // Afficher le message final de victoire
    function showFinalMessage() {
      // Insérer le texte de conclusion dans l'élément final-text
      finalText.innerHTML = 
        "<p>Bien joué&#8239;!</p>" +
        "<p>Après 7 ans dans le même bateau, je vais changer d’équipage et quitter Harris pour une autre aventure.</p>" +
        "<p>Tu as prouvé ta valeur aujourd’hui&nbsp;; je t’invite à rejoindre de la même façon mon pot de départ le <span class='highlight-date'>jeudi 7 novembre</span>, à la cafèt, avant de se déhaler vers une autre destination plus festive&nbsp;!</p>";
      // Afficher l'écran de fin avec le message
      finalScreen.style.display = 'flex';
      // Marquer l'état comme terminé
      gameState = 'ended';
    }
    // Gestion de l'échec (collision ou erreur de passage)
    function failGame(message) {
      gameState = 'fail';
      // Arrêter la génération d'obstacles
      clearInterval(spawnIntervalId);
      spawnIntervalId = null;
      // Afficher un message d'échec temporaire en overlay
      const failOverlay = document.createElement('div');
      failOverlay.className = 'overlay';
      failOverlay.innerHTML = `<div><p>${message}</p></div>`;
      gameContainer.appendChild(failOverlay);
      // Après 3 secondes, retirer le message d'échec et redémarrer automatiquement
      setTimeout(() => {
        gameContainer.removeChild(failOverlay);
        startGame();
      }, 3000);
    }
    // Générer un obstacle aléatoire (appelé à intervalle régulier pendant le jeu)
    function spawnObstacle() {
      if (gameState !== 'playing') return;
      // Choisir aléatoirement le type parmi rocher, bouée rouge, bouée verte
      const types = ['rock', 'red', 'green'];
      const type = types[Math.floor(Math.random() * types.length)];
      let x = 0;
      // Calculer la position horizontale du spawn selon le type
      if (type === 'rock') {
        // Rocher : peut apparaître n'importe où (en restant dans l'écran)
        x = Math.random() * (containerWidth - spriteSizes.rock.w);
      } else if (type === 'red') {
        // Bouée rouge : zone 30% - 50% de la largeur de l'écran
        const minX = 0.3 * containerWidth;
        const maxX = 0.5 * containerWidth;
        x = minX + Math.random() * (maxX - minX - spriteSizes.red.w);
      } else if (type === 'green') {
        // Bouée verte : zone 50% - 70% de la largeur
        const minX = 0.5 * containerWidth;
        const maxX = 0.7 * containerWidth;
        x = minX + Math.random() * (maxX - minX - spriteSizes.green.w);
      }
      const y = -spriteSizes[type].h; // spawn juste au-dessus du champ de jeu
      // Créer et ajouter l'obstacle
      const obstacle = createObstacle(type, x, y);
      obstacles.push(obstacle);
    }
    // Boucle de jeu principale (rafraîchissement à chaque frame)
    let gameLoopRunning = false;
    function gameLoop() {
      // Mettre à jour le fond et les obstacles pendant la phase de jeu
      if (gameState === 'playing') {
        // Faire défiler le fond (vers le bas en incrémentant backgroundOffset)
        backgroundOffset += baseSpeed * speedFactor;
        if (backgroundOffset >= 16) {
          backgroundOffset -= 16;
        }
        gameContainer.style.backgroundPosition = 'center ' + backgroundOffset + 'px';
      }
      if (gameState === 'playing') {
        // Mettre à jour la position de chaque obstacle
        for (let i = 0; i < obstacles.length; i++) {
          const obs = obstacles[i];
          // Descendre l'obstacle (mouvement vertical)
          obs.y += baseSpeed * speedFactor;
          obs.elem.style.top = obs.y + 'px';
          // Si l'obstacle sort de l'écran par le bas, il est considéré franchi
          if (obs.y > containerHeight) {
            // Si c'est une bouée, vérifier que le bateau est passé du bon côté
            if (obs.type === 'red' || obs.type === 'green') {
              const boatCenterX = boatX + spriteSizes.boat.w / 2;
              const buoyCenterX = obs.x + spriteSizes[obs.type].w / 2;
              if ((obs.type === 'red' && boatCenterX <= buoyCenterX) ||
                  (obs.type === 'green' && boatCenterX >= buoyCenterX)) {
                // Mauvais côté de la bouée -> échec
                if (obs.type === 'red') {
                  failGame("On doit passer à droite des bouées bâbord rouges&nbsp;! Marin d'eau douce&nbsp;!");
                } else {
                  failGame("On doit passer à gauche des bouées tribord vertes&nbsp;! Même Fred&nbsp;!");
                }
                return; // arrêter la boucle jusqu'au redémarrage
              }
            }
            // L'obstacle a été évité correctement (ou c'était un rocher non percuté)
            obstaclesPassed++;
            removeObstacle(i);
            i--;
            // Si 12 obstacles franchis, déclencher la victoire
            if (obstaclesPassed >= 12) {
              winGame();
              // (On ne quitte pas la boucle, on veut enchaîner avec finalApproach)
            }
            continue;
          }
          // Vérifier collision entre le bateau et l'obstacle (en cours de jeu)
          if (gameState === 'playing') {
            const boatLeft   = boatX;
            const boatRight  = boatX + spriteSizes.boat.w;
            const boatTop    = boatY;
            const boatBottom = boatY + spriteSizes.boat.h;
            const obsLeft   = obs.x;
            const obsRight  = obs.x + obs.w;
            const obsTop    = obs.y;
            const obsBottom = obs.y + obs.h;
            if (!(boatRight < obsLeft || boatLeft > obsRight || boatBottom < obsTop || boatTop > obsBottom)) {
              // Collision détectée
              if (obs.type === 'rock') {
                failGame("Tu t'es échoué&nbsp;! Tu dois sûrement être un quanti\u2026");
              } else if (obs.type === 'red') {
                failGame("On doit passer à droite des bouées bâbord rouges&nbsp;! Marin d'eau douce&nbsp;!");
              } else if (obs.type === 'green') {
                failGame("On doit passer à gauche des bouées tribord vertes&nbsp;! Même Fred&nbsp;!");
              }
              return;
            }
          }
        }
      }
      if (gameState === 'finalApproach') {
        // Le jeu est en phase finale : bateau se dirige vers le drapeau
        // Fixer le fond sur la dernière position (on ne le fait plus défiler)
        gameContainer.style.backgroundPosition = 'center ' + backgroundOffset + 'px';
        // Calculer la cible horizontale (centre de l'écran)
        const targetX = (containerWidth - spriteSizes.boat.w) / 2;
        // Déplacer progressivement le bateau vers le centre (adoucissement du mouvement)
        if (Math.abs(boatX - targetX) > 1) {
          boatX += (targetX - boatX) * 0.02;
        }
        // Faire monter le bateau vers le haut de l'écran
        boatY -= baseSpeed * 2; // vitesse ascendante du bateau (plus rapide que baseSpeed)
        if (boatY < 50) {
          boatY = 50;
        }
        boat.style.left = boatX + 'px';
        boat.style.top = boatY + 'px';
        // Vérifier si le bateau a atteint le drapeau (collision bateau-drapeau)
        const flagElem = document.querySelector('.flag');
        if (flagElem) {
          const flagRect = flagElem.getBoundingClientRect();
          const boatRect = boat.getBoundingClientRect();
          if (!(boatRect.right < flagRect.left || boatRect.left > flagRect.right ||
                boatRect.bottom < flagRect.top || boatRect.top > flagRect.bottom)) {
            // Bateau arrive au drapeau -> victoire
            flagElem.parentNode.removeChild(flagElem);
            showFinalMessage();
          }
        }
      }
      // Continuer la boucle de jeu (stopper si le jeu est terminé)
      if (gameState !== 'ended') {
        requestAnimationFrame(gameLoop);
      }
    }
    // Gestion des entrées clavier
    document.addEventListener('keydown', function(e) {
      if (gameState === 'start') {
        // Avant le début : Espace pour lancer le jeu
        if (e.code === 'Space') {
          if (autoStartTimer) {
            clearTimeout(autoStartTimer);
            autoStartTimer = null;
          }
          startGame();
        }
      } else if (gameState === 'playing') {
        // ** Astuce : si audio non lancé (autoplay bloqué), le démarrer à la première interaction clavier **
        if (audio.paused) {
          audio.play().catch(err => {});
        }
        if (e.code === 'ArrowLeft') {
          // Déplacer le bateau vers la gauche
          boatX -= boatSpeedX;
          if (boatX < 0) boatX = 0;
        } else if (e.code === 'ArrowRight') {
          // Déplacer le bateau vers la droite
          boatX += boatSpeedX;
          if (boatX > containerWidth - spriteSizes.boat.w) {
            boatX = containerWidth - spriteSizes.boat.w;
          }
        } else if (e.code === 'ArrowUp') {
          // Augmenter un peu la vitesse de défilement (accélérer)
          speedFactor = 1.5;
        } else if (e.code === 'ArrowDown') {
          // Diminuer un peu la vitesse de défilement (ralentir)
          speedFactor = 0.75;
        }
        // Appliquer la nouvelle position du voilier immédiatement
        boat.style.left = boatX + 'px';
        boat.style.top = boatY + 'px';
      } else if (gameState === 'finalApproach' || gameState === 'ended') {
        // En phase finale ou après, on ignore les entrées (aucune action supplémentaire)
      }
    });
    document.addEventListener('keyup', function(e) {
      if (gameState === 'playing') {
        // Relâcher flèche haut/bas -> revenir à la vitesse normale
        if (e.code === 'ArrowUp' || e.code === 'ArrowDown') {
          speedFactor = 1;
        }
      }
    });
    // Initialisation une fois la page chargée
    window.onload = function() {
      // Obtenir les dimensions du conteneur de jeu
      containerWidth = gameContainer.clientWidth;
      containerHeight = gameContainer.clientHeight;
      // Positionner le bateau au centre horizontal, 80% de la hauteur (bas de l'écran)
      boatX = (containerWidth - spriteSizes.boat.w) / 2;
      boatY = containerHeight * 0.8;
      boat.style.left = boatX + 'px';
      boat.style.top = boatY + 'px';
      // Lancer le jeu automatiquement après 8 secondes si Espace non pressé
      autoStartTimer = setTimeout(() => {
        if (gameState === 'start') {
          startGame();
        }
      }, 8000);
    };
  </script>
</body>
</html>
