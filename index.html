<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HastaLuego</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: #000; /* noir autour si écran plus grand */
    }
    body {
      /* Zone de jeu occupant tout l'écran */
      width: 100vw; height: 100vh;
    }
    #game {
      position: relative;
      width: 100%; height: 100%;
      /* Fond marin pixelisé en répétition (scrolling animé) */
      background: url("data:image/png;base64,<?php echo $b64_water; ?>") repeat;
      animation: scrollBg 10s linear infinite;
      image-rendering: pixelated;
    }
    @keyframes scrollBg {
      from { background-position: 0 0; }
      to   { background-position: 0 100%; }
    }
    /* Sprite communs */
    .sprite {
      position: absolute;
      image-rendering: pixelated; /* conserver effet pixel art */
    }
    /* Bateau du joueur */
    #boat {
      width: 32px; height: 32px;
      background: url("data:image/png;base64,<?php echo $b64_boat; ?>") no-repeat;
    }
    /* Objets obstacles */
    .obstacle { width: 16px; height: 16px; }
    .obstacle.red {
      background: url("data:image/png;base64,<?php echo $b64_red; ?>") no-repeat;
    }
    .obstacle.green {
      background: url("data:image/png;base64,<?php echo $b64_green; ?>") no-repeat;
    }
    .obstacle.rock {
      background: url("data:image/png;base64,<?php echo $b64_rock; ?>") no-repeat;
    }
    .obstacle.flag {
      width: 16px; height: 16px;
      background: url("data:image/png;base64,<?php echo $b64_flag; ?>") no-repeat;
    }
    /* Overlay de message (instructions et échecs) */
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
      z-index: 10;
    }
    #overlay p {
      font-size: 1.2em;
      margin: 0.5em;
    }
    /* Carte finale */
    #finalCard {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      background: rgba(255, 255, 255, 0.9);
      color: #000;
      border: 2px solid #000;
      border-radius: 10px;
      padding: 20px;
      width: 80%;
      max-width: 600px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      text-align: center;
      z-index: 20;
    }
    #finalCard .highlight {
      color: goldenrod;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="game">
    <!-- Bateau du joueur -->
    <div id="boat" class="sprite"></div>
    <!-- Overlay de démarrage/échec -->
    <div id="overlay">
      <p>À l’aide des touches directionnelles, emmène ton bateau à bon port !</p>
      <p>Appuie sur <strong>ESPACE</strong> pour commencer</p>
    </div>
  </div>
  <!-- Carte finale (pot de départ) -->
  <div id="finalCard">
    <p><strong>Bien joué !</strong></p>
    <p>Après 7 ans dans le même bateau, je vais changer d’équipage et quitter Harris pour une autre aventure.</p>
    <p>Tu as prouvé ta valeur aujourd’hui ; je t’invite à rejoindre de la même façon mon pot de départ le <span class="highlight">jeudi 7 novembre</span>, à la cafèt, avant de se déhaler vers une autre destination plus festive !</p>
  </div>
  <!-- Musique de fond -->
  <audio id="music" src="assets/hasta-luego.mp3" preload="auto" loop></audio>
  
  <script>
    // Élément du bateau et conteneur principal
    const boat = document.getElementById('boat');
    const gameArea = document.getElementById('game');
    const overlay = document.getElementById('overlay');
    const finalCard = document.getElementById('finalCard');
    const music = document.getElementById('music');
    // Dimensions de la zone de jeu et du bateau
    let gameWidth = window.innerWidth;
    let gameHeight = window.innerHeight;
    const boatWidth = 32, boatHeight = 32;
    // Position du bateau (coordonnées absolues en pixels)
    let boatX = (gameWidth - boatWidth) / 2;
    let boatY = gameHeight * 0.66;  // ~66% de la hauteur depuis le haut (1/3 depuis le bas)
    boat.style.top = boatY + 'px';
    boat.style.left = boatX + 'px';
    // État du jeu
    let gameStarted = false;
    let gameActive = false;
    let finalPhase = false;
    // Obstacles en cours
    let obstacles = [];  // tableau d'objets {elem, type, x, y}
    let obstacleCount = 0;
    let spawnIntervalId = null;
    // Contrôles clavier (gauche/droite)
    const keys = { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false };
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        // Démarrage du jeu via ESPACE
        if (!gameStarted) {
          startGame();
          gameStarted = true;
        }
      } else if (e.code in keys) {
        keys[e.code] = true;
        e.preventDefault();
      }
    });
    document.addEventListener('keyup', (e) => {
      if (e.code in keys) {
        keys[e.code] = false;
        e.preventDefault();
      }
    });
    // Lancement auto après 8 secondes si non déjà lancé
    setTimeout(() => {
      if (!gameStarted) {
        startGame();
        gameStarted = true;
      }
    }, 8000);
    // Fonction de démarrage / redémarrage du jeu
    function startGame() {
      // Masquer les éventuels écrans (overlay de titre ou message d'échec)
      overlay.style.display = 'none';
      finalCard.style.display = 'none';
      // Réinitialiser l'état
      obstacleCount = 0;
      finalPhase = false;
      // Supprimer tous les obstacles existants
      for (let obs of obstacles) {
        if (obs.elem && obs.elem.parentNode) {
          obs.elem.parentNode.removeChild(obs.elem);
        }
      }
      obstacles = [];
      // Recentrer le bateau
      boatX = (window.innerWidth - boatWidth) / 2;
      boatY = window.innerHeight * 0.66;
      boat.style.left = boatX + 'px';
      boat.style.top = boatY + 'px';
      // Démarrer la musique si pas déjà lancée
      if (music.paused) {
        music.play().catch(err => { /* mute error (autoplay) */ });
      }
      // Commencer la boucle du jeu
      gameActive = true;
      requestAnimationFrame(gameLoop);
      // Planifier l'apparition des obstacles
      if (spawnIntervalId) clearInterval(spawnIntervalId);
      spawnIntervalId = setInterval(spawnObstacle, 2000);
    }
    // Boucle principale du jeu (appelée chaque frame)
    function gameLoop() {
      if (!gameActive) return;
      // Mise à jour du déplacement du bateau selon les touches (gauche/droite)
      if (keys.ArrowLeft) {
        boatX -= 4;
        if (boatX < 0) boatX = 0;
      }
      if (keys.ArrowRight) {
        boatX += 4;
        if (boatX + boatWidth > window.innerWidth) {
          boatX = window.innerWidth - boatWidth;
        }
      }
      // (Optionnel : on pourrait autoriser un léger mouvement vertical si voulu)
      // Mettre à jour la position du bateau
      boat.style.left = boatX + 'px';
      // Si en phase finale, le bateau avance vers le haut automatiquement
      if (finalPhase) {
        boatY -= 2; // vitesse de montée du bateau
        if (boatY < 0) boatY = 0;
        boat.style.top = boatY + 'px';
      }
      // Parcourir les obstacles pour les déplacer et détecter collisions
      for (let i = 0; i < obstacles.length; i++) {
        const obs = obstacles[i];
        // Si ce n'est pas la phase finale ou obstacle pas un drapeau, faire descendre l’obstacle
        if (!(obs.type === 'flag' && finalPhase)) {
          obs.y += 2;  // vitesse de descente des obstacles
          obs.elem.style.top = obs.y + 'px';
        }
        // Retirer les obstacles sortis de l'écran
        if (obs.y > window.innerHeight) {
          // Si c'était une bouée, on considère qu'elle a été passée du bon côté (pas de fail déclenché)
          // On peut l'enlever du DOM
          obs.elem.parentNode.removeChild(obs.elem);
          obstacles.splice(i, 1);
          i--;
          continue;
        }
        // Détection de collision avec le bateau (bounding box)
        const boatRect = {x: boatX, y: boatY, w: boatWidth, h: boatHeight};
        const obsRect = {x: obs.x, y: obs.y, w: (obs.type === 'flag' ? 16 : 16), h: (obs.type === 'flag' ? 16 : 16)};
        const overlapX = boatRect.x < obsRect.x + obsRect.w && boatRect.x + boatRect.w > obsRect.x;
        const overlapY = boatRect.y < obsRect.y + obsRect.h && boatRect.y + boatRect.h > obsRect.y;
        if (overlapX && overlapY) {
          if (obs.type === 'flag') {
            // Collision avec le drapeau final -> victoire
            reachFinal();
            return; // terminer la loop
          } else {
            // Collision avec un rocher ou une bouée -> échec
            failGame("Tu t’es échoué ! Tu dois sûrement être un quanti…");
            return;
          }
        }
        // Si obstacle est une bouée et qu’il vient d’être dépassé (passage à gauche/droite)
        if ((obs.type === 'red' || obs.type === 'green') && !obs.passed) {
          if (obs.y > boatY + boatHeight) {
            obs.passed = true; // marquer comme traité
            // Vérifier de quel côté le bateau l’a passée
            const boatCenter = boatX + boatWidth / 2;
            const obsCenter = obs.x + 8; // 8 px = la moitié de 16px (centre de la bouée)
            if (obs.type === 'red' && boatCenter < obsCenter) {
              // Passé à gauche d’une bouée rouge (erreur)
              failGame("On doit passer à droite des bouées bâbord rouges ! Marin d’eau douce !");
              return;
            }
            if (obs.type === 'green' && boatCenter > obsCenter) {
              // Passé à droite d’une bouée verte (erreur)
              failGame("On doit passer à gauche des bouées tribord vertes ! Même Fred !");
              return;
            }
            // Sinon bon côté, on ne fait rien (le jeu continue)
          }
        }
      }
      // Prochaine frame
      requestAnimationFrame(gameLoop);
    }
    // Fonction de création d’un obstacle (appelée périodiquement)
    function spawnObstacle() {
      if (obstacleCount >= 12) {
        // Au bout de 12 obstacles, on place le drapeau final
        clearInterval(spawnIntervalId);
        spawnFinalFlag();
        return;
      }
      // Choisir un type d’obstacle aléatoire parmi 'rock', 'red', 'green'
      const types = ['rock', 'red', 'green'];
      const type = types[Math.floor(Math.random() * types.length)];
      // Créer l’élément DOM de l’obstacle
      const elem = document.createElement('div');
      elem.classList.add('sprite', 'obstacle', type);
      // Position de départ aléatoire en X (en évitant bords pour laisser la place de passer)
      const obsWidth = 16;
      let x = Math.random() * (window.innerWidth - obsWidth);
      // Éviter que l’obstacle n’apparaisse trop près des bords extrêmes
      if (x < 20) x = 20;
      if (x > window.innerWidth - obsWidth - 20) x = window.innerWidth - obsWidth - 20;
      const y = -obsWidth; // juste au-dessus de l’écran
      elem.style.left = x + 'px';
      elem.style.top = y + 'px';
      // Ajouter dans la zone de jeu
      gameArea.appendChild(elem);
      // Enregistrer l’obstacle
      obstacles.push({ elem: elem, type: type, x: x, y: y, passed: false });
      obstacleCount++;
    }
    // Générer le drapeau final et initier la phase finale
    function spawnFinalFlag() {
      // Supprimer tous les obstacles restants (on part d’une mer dégagée)
      for (let obs of obstacles) {
        if (obs.elem && obs.elem.parentNode) {
          obs.elem.parentNode.removeChild(obs.elem);
        }
      }
      obstacles = [];
      // Créer le drapeau
      const flagElem = document.createElement('div');
      flagElem.classList.add('sprite', 'obstacle', 'flag');
      // Placer le drapeau en haut de l’écran, aligné horizontalement avec le bateau actuel
      const flagX = boatX + boatWidth/2 - 8; // centrer le drapeau sur la position du bateau
      if (flagX < 0) flagX = 0;
      if (flagX > window.innerWidth - 16) flagX = window.innerWidth - 16;
      const flagY = 0;
      flagElem.style.left = flagX + 'px';
      flagElem.style.top = flagY + 'px';
      gameArea.appendChild(flagElem);
      // Enregistrer le drapeau comme obstacle
      obstacles.push({ elem: flagElem, type: 'flag', x: flagX, y: flagY });
      // Passer en phase finale : le bateau va se déplacer vers le haut
      finalPhase = true;
    }
    // Gérer l’échec du jeu (collision ou mauvaise manœuvre)
    function failGame(message) {
      // Arrêter le jeu
      gameActive = false;
      clearInterval(spawnIntervalId);
      // Afficher le message d’erreur
      overlay.innerHTML = "<p>" + message + "</p>";
      overlay.style.display = 'flex';
      // Repartir au bout de 3 secondes
      setTimeout(() => {
        startGame();
      }, 3000);
    }
    // Gérer la réussite finale
    function reachFinal() {
      gameActive = false;
      clearInterval(spawnIntervalId);
      // Arrêter l'animation du fond (bateau arrivé au port)
      gameArea.style.animationPlayState = 'paused';
      // Afficher la carte finale
      finalCard.style.display = 'block';
    }
  </script>
</body>
</html>
