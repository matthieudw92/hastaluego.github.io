<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>HastaLuego</title>
  <style>
    html, body, #game {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #game {
      position: relative;
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAARUlEQVR4nIWPyQ0AIAgEB6qzKynLEuxKHyrExIMPmZ1kCQK1QQESp60vCQkZDcyAKYPVwTIxwQLWXieiwat31ptY/P2iA8PsHUERO+Q7AAAAAElFTkSuQmCC") repeat;
      /* Scrolling water background animation */
      animation: scrollBg 4s linear infinite;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    @keyframes scrollBg {
      from { background-position: 0 0; }
      to   { background-position: 0 8px; }
    }
    #intro, #message {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      flex-direction: column;
      padding: 20px;
      box-sizing: border-box;
      z-index: 200;
    }
    #intro h1 {
      font-size: 2em;
      margin: 0 0 0.5em;
    }
    #intro p, #message p {
      font-size: 1.2em;
      margin: 0;
    }
    #message {
      background: rgba(0, 0, 0, 0.5);
      display: none;
    }
    #boat, .obstacle {
      position: absolute;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #boat { z-index: 100; }
    .obstacle { z-index: 50; }
  </style>
</head>
<body>
  <div id="game">
    <div id="intro">
      <h1>HastaLuego</h1>
      <p>Appuyez sur <kbd>Espace</kbd> pour démarrer<br/>ou patientez pour un démarrage automatique.</p>
    </div>
    <div id="message"></div>
    <img id="boat" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcklEQVR4nGNgoDX4////f4o0pzor/sdnCBPZphMyAN1WXK7AagAuxdjEqe8FQqGOLs+ET5IYQyj2AiM2U3vcROAKbv3jY1Bj+gTnl+x6g9DMyMjIhMyBAWQbkDVjU4fhhW5XYbzhgC5P3WgkZDup6ogCABHDQG6rOLT2AAAAAElFTkSuQmCC" alt="Bateau" />
    <!-- Obstacle elements will be generated by the script -->
    <audio id="bgm" src="assets/hasta-luego.mp3" preload="auto"></audio>
  </div>
  <script>
    // Game variables and configuration
    const scale = 3;  // scaling factor for sprite sizes (pixel art scaled up)
    const assetData = {
      rock:   { src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbElEQVR4nGNgGAUEQZSN3P8oG7n/uOSZiDGkJMoIpxxeA6Js5P47KfLgNZwoF5w7fovh3LQArN7AaQA+fxPtAnTnY3MFUV5gYIB4g2gX4As8dFcQ7QJcgCwDkF2BYQBe52MJBxQDiI06ZFcAAFmRI4TX2IdiAAAAAElFTkSuQmCC", w: 16, h: 16 },
      buoyR:  { src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAL0lEQVR4nGP839Dwn4EIwMLAwMBwccMGvIo2XLjAwESMaQwMDCNUIQsDAyScCAEAQoQJ59H4WLEAAAAASUVORK5CYII=", w: 10, h: 10 },
      buoyG:  { src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAP0lEQVR4nGNgwAZSGP6jCzGhC0x4NwFDEVaFuExFUYjLNPwmopkKV4jPNMImIpnKRIxpxJkINZWJGNMYGBgYAHVCFkOaCAs+AAAAAElFTkSuQmCC", w: 10, h: 10 },
      flag:   { src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAOUlEQVR4nGNgoAswMjL6//86w39i1LIgc3BpYtRkYMSqAZcinDbgUoQMmGAM42gjQmpRNRALhoMGAK1TCJnJMiUeAAAAAElFTkSuQmCC", w: 12, h: 12 }
    };
    const totalObstacles = 12;      // number of obstacles before finish
    const obstacleSpeed = 3;        // vertical speed of obstacles (pixels per frame)
    const boatSpeed = 4;            // horizontal speed of boat (pixels per frame)
    const spawnInterval = 1500;     // interval between obstacle spawns (ms)
    let container, boatEl, messageEl;
    let containerW, containerH;
    let boatX, boatY, boatW, boatH;
    let keys = { left: false, right: false };
    let obstacles = [];             // active obstacles {type, x, y, w, h, el}
    let obstaclesPassed = 0;        // count of obstacles successfully passed
    let gameStarted = false;
    let gameOver = false;
    const audio = document.getElementById("bgm");
    // Initialize game elements positions
    container = document.getElementById("game");
    boatEl = document.getElementById("boat");
    messageEl = document.getElementById("message");
    containerW = container.clientWidth;
    containerH = container.clientHeight;
    // Set initial boat position (bottom center)
    boatW = boatEl.offsetWidth;
    boatH = boatEl.offsetHeight;
    boatX = (containerW - boatW) / 2;
    boatY = containerH - boatH - 10;
    boatEl.style.left = boatX + "px";
    boatEl.style.top = boatY + "px";
    // Function to create a new obstacle element and add to DOM
    function createObstacle(type, xPos) {
      const data = assetData[type];
      const obsEl = document.createElement("img");
      obsEl.src = data.src;
      obsEl.width = data.w * scale;
      obsEl.height = data.h * scale;
      obsEl.className = "obstacle";
      obsEl.alt = type;
      // position at given x, starting just above the visible area
      obsEl.style.left = xPos + "px";
      obsEl.style.top = (-data.h * scale) + "px";
      container.appendChild(obsEl);
      // Track obstacle in array
      obstacles.push({
        type: type,
        x: xPos,
        y: -data.h * scale,
        w: obsEl.offsetWidth,
        h: obsEl.offsetHeight,
        el: obsEl
      });
    }
    // Spawn the next obstacle or the finish flag
    let spawnedCount = 0;
    let lastSpawnTime = 0;
    function spawnNext() {
      if (spawnedCount < totalObstacles) {
        // Randomly choose obstacle type
        const types = ["rock", "buoyR", "buoyG"];
        const type = types[Math.floor(Math.random() * types.length)];
        // Determine spawn X based on type
        let minX = 0, maxX = containerW - assetData[type].w * scale;
        if (type === "buoyR") {
          minX = 0.30 * containerW;
          maxX = 0.50 * containerW - assetData[type].w * scale;
        } else if (type === "buoyG") {
          minX = 0.50 * containerW;
          maxX = 0.70 * containerW - assetData[type].w * scale;
        } else if (type === "rock") {
          minX = 0.10 * containerW;
          maxX = 0.90 * containerW - assetData[type].w * scale;
        }
        if (maxX < minX) maxX = minX;  // safety check
        const spawnX = minX + Math.random() * (maxX - minX);
        createObstacle(type, spawnX);
        spawnedCount++;
      } else if (spawnedCount === totalObstacles) {
        // All obstacles done, spawn finish flag at boat's current position
        createObstacle("flag", boatX + (boatW - assetData.flag.w * scale) / 2);
        spawnedCount++;
      }
    }
    // Game loop function
    function gameLoop(timestamp) {
      if (gameOver) return;  // stop loop if game ended
      // Spawn obstacles at intervals
      if (gameStarted && timestamp - lastSpawnTime > spawnInterval) {
        spawnNext();
        lastSpawnTime = timestamp;
      }
      // Move boat based on input keys
      if (keys.left) {
        boatX -= boatSpeed;
        if (boatX < 0) boatX = 0;
      }
      if (keys.right) {
        boatX += boatSpeed;
        if (boatX > containerW - boatW) boatX = containerW - boatW;
      }
      boatEl.style.left = boatX + "px";
      // Move obstacles
      for (let i = 0; i < obstacles.length; i++) {
        const obs = obstacles[i];
        obs.y += obstacleSpeed;
        obs.el.style.top = obs.y + "px";
        // Remove obstacles that move off-screen (for non-flag obstacles count as passed)
        if (obs.y > containerH) {
          container.removeChild(obs.el);
          obstacles.splice(i, 1);
          i--;
          if (obs.type !== "flag") {
            obstaclesPassed++;
            // If all normal obstacles passed, we will spawn the flag (if not already spawned)
            if (obstaclesPassed === totalObstacles && spawnedCount === totalObstacles) {
              // Delay flag spawn slightly to show a gap
              setTimeout(() => { spawnNext(); }, 500);
              lastSpawnTime = timestamp;  // reset spawn timer
            }
          }
          continue;
        }
        // Collision detection (AABB)
        const boatRect = { left: boatX, right: boatX + boatW, top: boatY, bottom: boatY + boatH };
        const obsRect = { left: obs.x, right: obs.x + obs.w, top: obs.y, bottom: obs.y + obs.h };
        const overlap = !(boatRect.right < obsRect.left || boatRect.left > obsRect.right || boatRect.bottom < obsRect.top || boatRect.top > obsRect.bottom);
        if (overlap) {
          if (obs.type === "flag") {
            // Reached finish flag - success
            gameOver = true;
            showMessage("Félicitations ! Vous avez atteint l’arrivée le <span style='color: #ff0; font-weight:bold;'>jeudi 7 novembre</span>.");
            // Stop game (no restart, game completed)
          } else {
            // Collision with rock or buoy - failure
            gameOver = true;
            if (obs.type === "rock") {
              showMessage("Oups ! Vous avez heurté un rocher !");
            } else if (obs.type === "buoyR") {
              showMessage("Erreur : la bouée rouge doit être contournée par la droite !");
            } else if (obs.type === "buoyG") {
              showMessage("Erreur : la bouée verte doit être contournée par la gauche !");
            }
            // Reset game after a short delay
            setTimeout(() => { location.reload(); }, 4000);
          }
          // Remove all remaining obstacles from DOM
          obstacles.forEach(o => { if (o.el.parentNode) container.removeChild(o.el); });
          obstacles = [];
          break;  // exit loop on collision
        }
      }
      // Continue loop
      if (!gameOver) {
        requestAnimationFrame(gameLoop);
      }
    }
    // Display a message overlay
    function showMessage(text) {
      messageEl.innerHTML = "<p>" + text + "</p>";
      messageEl.style.display = "flex";
    }
    // Start the game (called on space or auto-start)
    function startGame() {
      if (gameStarted) return;
      gameStarted = true;
      document.getElementById("intro").style.display = "none";
      // Try to play background music (may require user interaction depending on browser)
      audio.play().catch(err => { /* Audio may be blocked until user interacts */ });
      lastSpawnTime = performance.now();
      requestAnimationFrame(gameLoop);
    }
    // Key event handlers
    document.addEventListener("keydown", function(e) {
      if (e.code === "ArrowLeft" || e.code === "ArrowRight" || e.code === "Space") {
        e.preventDefault();  // prevent scrolling with arrow keys or space
      }
      if (e.code === "ArrowLeft") keys.left = true;
      if (e.code === "ArrowRight") keys.right = true;
      if (e.code === "Space") {
        if (!gameStarted) {
          startGame();
        }
      }
    });
    document.addEventListener("keyup", function(e) {
      if (e.code === "ArrowLeft") keys.left = false;
      if (e.code === "ArrowRight") keys.right = false;
    });
    // Auto-start game after 8 seconds if not started yet
    setTimeout(() => { startGame(); }, 8000);
  </script>
</body>
</html>
