<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>HastaLuego - Mini Jeu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Pixel art font (Press Start 2P) -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    /* Reset and basic styles */
    * { box-sizing: border-box; padding: 0; margin: 0; }
    html, body { width: 100%; height: 100%; background: #4dc0ff; /* ocean blue */ overflow: hidden; }
    body { font-family: 'Press Start 2P', monospace; }
    /* Game container */
    #game {
      position: relative;
      width: 100%;
      height: 100%;
      /* Ocean background with pixel waves pattern (data URI image) */
      background-color: #4dc0ff;
      background-image: url('data:image/png;base64,INSERT_BASE64_WAVE_TEXTURE_HERE');
      background-repeat: repeat;
      animation: scrollWaves 10s linear infinite;
    }
    @keyframes scrollWaves {
      from { background-position-y: 0; }
      to { background-position-y: 100%; }
    }
    /* Boat sprite */
    #boat {
      position: absolute;
      bottom: 15%; /* position boat in lower third */
      left: 50%;
      transform: translateX(-50%);
      width: 32px; height: 32px; /* boat sprite size */
      background: url('data:image/png;base64,INSERT_BASE64_BOAT_SPRITE_HERE') no-repeat;
      image-rendering: pixelated;
    }
    /* Obstacles (common) */
    .obstacle {
      position: absolute;
      width: 20px; height: 20px; /* default size, overridden per type */
      image-rendering: pixelated;
    }
    /* Specific obstacle styles */
    .rock {
      width: 24px; height: 24px;
      background: url('data:image/png;base64,INSERT_BASE64_ROCK_SPRITE_HERE') no-repeat;
    }
    .buoyRed {
      width: 16px; height: 16px;
      background: url('data:image/png;base64,INSERT_BASE64_REDBUOY_SPRITE_HERE') no-repeat;
    }
    .buoyGreen {
      width: 16px; height: 16px;
      background: url('data:image/png;base64,INSERT_BASE64_GREENBUOY_SPRITE_HERE') no-repeat;
    }
    .flag {
      width: 16px; height: 16px;
      background: url('data:image/png;base64,INSERT_BASE64_FLAG_SPRITE_HERE') no-repeat;
    }
    /* Start screen and message overlay */
    .overlay {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,80, 0.8);
      color: #fff;
      padding: 20px;
      border: 2px solid #fff;
      width: 80%;
      max-width: 400px;
      text-align: center;
      font-size: 14px;
      line-height: 1.5;
    }
    #startScreen.overlay { /* initial instruction screen */
      font-size: 12px;
    }
    #prompt { 
      display: block;
      margin-top: 10px;
      font-size: 10px;
      color: #ff0;
      animation: blink 1s step-start 0s infinite;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
    /* Highlight for special text (e.g., date) */
    .highlight { color: #ff0; text-decoration: underline; }
  </style>
</head>
<body>
<div id="game">
  <!-- Boat element -->
  <div id="boat"></div>
  <!-- Obstacles will be dynamically added here -->
  <!-- Start screen overlay -->
  <div id="startScreen" class="overlay">
    <p>À l’aide des touches directionnelles, emmène ton bateau à bon port !</p>
    <p id="prompt">[ESPACE] pour commencer</p>
  </div>
  <!-- Message overlay (for fail/win messages) -->
  <div id="message" class="overlay" style="display:none;"></div>
</div>
<!-- Background music -->
<audio id="bgm" src="INSERT_MUSIC_FILE_URL_OR_PATH_HERE" loop></audio>
<script>
(function(){
  // Game state and constants
  const game = document.getElementById('game');
  const boat = document.getElementById('boat');
  const startScreen = document.getElementById('startScreen');
  const messageOverlay = document.getElementById('message');
  const bgm = document.getElementById('bgm');
  let gameState = "start"; // "start", "playing", "gameover", "win"
  const boatSpeed = 4; // horizontal speed in pixels per frame
  const obstacleSpeed = 2; // vertical speed of obstacles (px per frame)
  const obstacles = []; // array to store obstacle objects {elem, type, x, y}
  const totalObstacles = 12;
  let boatVelocityX = 0;
  let animationFrameId;
  
  // Helper: create obstacle element
  function createObstacle(type, xPercent, yOffset) {
    const obs = document.createElement('div');
    obs.classList.add('obstacle');
    if (type === 'rock') obs.classList.add('rock');
    if (type === 'buoyRed') obs.classList.add('buoyRed');
    if (type === 'buoyGreen') obs.classList.add('buoyGreen');
    if (type === 'flag') obs.classList.add('flag');
    // position it
    obs.style.left = xPercent + '%';
    obs.style.top = (yOffset || -10) + 'px';
    game.appendChild(obs);
    obstacles.push({ elem: obs, type: type, 
                     width: obs.offsetWidth, height: obs.offsetHeight,
                     x: (xPercent/100) * game.clientWidth, // in pixels
                     y: yOffset || -10 });
  }
  
  // Initialize obstacle sequence
  function initObstacles() {
    // Remove any existing obstacle elements from DOM
    obstacles.forEach(o => game.removeChild(o.elem));
    obstacles.length = 0;
    // Example sequence: alternate some rocks and buoys and end with flag
    // We can hardcode positions or randomize within ranges:
    const types = ['rock','buoyRed','buoyGreen'];
    let yPos = -50;
    for (let i = 1; i <= totalObstacles; i++) {
      let type;
      if (i === totalObstacles) {
        type = 'flag'; // last obstacle is the finish flag
      } else {
        // alternate obstacles (for example, cycle through rock, red, green)
        type = types[(i-1) % types.length];
      }
      // Determine horizontal position range based on type:
      let xPerc;
      if (type === 'rock') {
        xPerc = 25 + Math.random() * 50; // 25% to 75% from left
      } else if (type === 'buoyRed') {
        xPerc = 30 + Math.random() * 25; // 30% to 55% range
      } else if (type === 'buoyGreen') {
        xPerc = 45 + Math.random() * 25; // 45% to 70% range
      } else if (type === 'flag') {
        xPerc = 50; // flag in middle (or could random, but middle is fine as goal)
      }
      createObstacle(type, xPerc, yPos);
      // Increase yPos for next obstacle to space them out vertically
      yPos -= 200; // space obstacles 200px apart vertically (appearing sequentially)
    }
  }
  
  // Start the game
  function startGame() {
    // Hide start screen and any message
    startScreen.style.display = 'none';
    messageOverlay.style.display = 'none';
    gameState = "playing";
    // Reset boat position to center bottom
    boat.style.left = "50%";
    boatVelocityX = 0;
    // Initialize obstacles course
    initObstacles();
    // Start background music if not already playing
    try { bgm.play().catch(e=>{ /* autoplay might be blocked if no interaction */ }); } catch(e){}
    // Begin animation loop
    animationFrameId = requestAnimationFrame(gameLoop);
  }
  
  // Handle game over (collision) with appropriate message
  function handleCrash(reasonType) {
    if (gameState !== "playing") return;
    gameState = "gameover";
    // Stop the game loop
    cancelAnimationFrame(animationFrameId);
    // Show failure message based on reason
    let msg = "";
    if (reasonType === "rock") {
      msg = "Tu t’es échoué ! Tu dois sûrement être un quanti…";
    } else if (reasonType === "buoyRed") {
      msg = "On doit passer à DROITE des bouées bâbord rouges ! Marin d’eau douce !";
    } else if (reasonType === "buoyGreen") {
      msg = "On doit passer à GAUCHE des bouées tribord vertes ! Même Fred !";
    }
    messageOverlay.textContent = msg;
    messageOverlay.style.display = 'block';
    // Restart after a delay
    setTimeout(() => {
      if (gameState === "gameover") { // ensure no other state (just in case)
        startGame();
      }
    }, 2000);
  }
  
  // Handle reaching the flag (win)
  function handleWin() {
    if (gameState !== "playing") return;
    gameState = "win";
    cancelAnimationFrame(animationFrameId);
    // Show victory/farewell message
    messageOverlay.innerHTML = "<p>Bien joué !<br/>" +
      "Après 7 ans dans le même bateau, je vais changer d’équipage et quitter Harris pour une autre aventure.<br/>" +
      "Tu as prouvé ta valeur aujourd’hui ; je t’invite à rejoindre de la même façon mon pot de départ le " +
      "<span class='highlight'>jeudi 6 novembre</span>, à la cafèt, avant de se déhaler vers une autre destination plus festive !</p>";
    messageOverlay.style.display = 'block';
    // (Optionally, you could stop or change music here, but not required)
  }
  
  // Game loop function
  function gameLoop() {
    // Move boat by velocity
    if (boatVelocityX !== 0) {
      // current left in px
      let boatRect = boat.getBoundingClientRect();
      let newLeft = boatRect.left + boatVelocityX;
      // boundaries:
      if (newLeft < 0) newLeft = 0;
      if (newLeft + boatRect.width > game.clientWidth) {
        newLeft = game.clientWidth - boatRect.width;
      }
      boat.style.left = newLeft + "px";
    }
    // Update obstacles positions
    for (let i = 0; i < obstacles.length; i++) {
      let obs = obstacles[i];
      obs.y += obstacleSpeed;
      obs.elem.style.top = obs.y + "px";
      if (obs.y > game.clientHeight) {
        // obstacle passed out of screen, we could remove it
        if (obs.elem.parentNode === game) {
          game.removeChild(obs.elem);
        }
        obstacles.splice(i, 1);
        i--;
        continue;
      }
      // Collision / pass check if near boat
      if (obs.y + obs.height >= boat.offsetTop) {
        if (obs.type === 'rock') {
          // Check rock collision
          let boatRect = boat.getBoundingClientRect();
          let obsRect = obs.elem.getBoundingClientRect();
          if (!(boatRect.right < obsRect.left || 
                boatRect.left > obsRect.right || 
                boatRect.bottom < obsRect.top || 
                boatRect.top > obsRect.bottom)) {
            // Overlap indicates collision
            handleCrash("rock");
            return; // exit loop
          }
        } else if (obs.type === 'buoyRed') {
          // If boat is left of buoy (wrong side for red)
          let boatCenter = boat.offsetLeft + boat.offsetWidth/2;
          let buoyCenter = obs.elem.offsetLeft + obs.elem.offsetWidth/2;
          if (boatCenter < buoyCenter) {
            handleCrash("buoyRed");
            return;
          }
        } else if (obs.type === 'buoyGreen') {
          // If boat is right of buoy (wrong side for green)
          let boatCenter = boat.offsetLeft + boat.offsetWidth/2;
          let buoyCenter = obs.elem.offsetLeft + obs.elem.offsetWidth/2;
          if (boatCenter > buoyCenter) {
            handleCrash("buoyGreen");
            return;
          }
        } else if (obs.type === 'flag') {
          // Reached the flag - win condition
          handleWin();
          return;
        }
      }
    }
    // Continue loop if still playing
    if (gameState === "playing") {
      animationFrameId = requestAnimationFrame(gameLoop);
    }
  }
  
  // Keyboard controls
  window.addEventListener('keydown', function(e) {
    if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
      e.preventDefault(); // prevent page scroll
    }
    if (gameState === "start") {
      if (e.code === 'Space') {
        // start the game on Space
        startGame();
      }
      return;
    }
    if (gameState === "playing") {
      if (e.code === 'ArrowLeft') {
        boatVelocityX = -boatSpeed;
      } else if (e.code === 'ArrowRight') {
        boatVelocityX = boatSpeed;
      }
    } else if (gameState === "win") {
      if (e.code === 'Space') {
        // If player wants to replay after winning
        gameState = "start";
        startScreen.style.display = 'block';
        messageOverlay.style.display = 'none';
      }
    }
  });
  window.addEventListener('keyup', function(e) {
    if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
      // stop boat when arrow keys released
      boatVelocityX = 0;
    }
  });
})();
</script>
</body>
</html>
